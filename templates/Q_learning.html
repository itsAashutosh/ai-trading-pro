<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RL Trading Analysis - AI Trading Pro</title>
    
    <style>
        /* STANDARDIZED CSS STYLES */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* Navigation */
        .navbar {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 2rem;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            background: linear-gradient(45deg, #00f5ff, #ff00ff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 1.5rem;
            font-weight: 700;
            text-decoration: none;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
        }
        
        .nav-links a {
            color: #aaa;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s, transform 0.2s;
            padding: 0.5rem 0;
        }
        
        .nav-links a:hover {
            color: #fff;
        }
        
        .nav-links a.active {
            color: #00f5ff;
            border-bottom: 2px solid #00f5ff;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            background: #00f5ff;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: #000;
        }

        /* Main Layout */
        .main-content {
            padding: 8rem 2rem 2rem 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(90deg, #00f5ff, #ff00ff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .market-status {
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .market-open {
            background: linear-gradient(90deg, #2ed573, #1dd1a1);
            box-shadow: 0 0 10px rgba(46, 213, 115, 0.5);
        }
        
        .market-closed {
            background: linear-gradient(90deg, #ff4757, #ff3838);
            box-shadow: 0 0 10px rgba(255, 71, 87, 0.5);
        }

        /* Grid Layout (Used here for sub-layout within the explanation card) */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr; /* Default to single column */
            gap: 2rem;
        }

        /* Card Styling */
        .card {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
        }
        
        .card h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #00f5ff;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding-bottom: 0.5rem;
        }
        
        .card p {
            margin-bottom: 10px;
            line-height: 1.6;
            color: #ccc;
        }

        /* Specific Card Sizes */
        .card-full { grid-column: 1 / -1; }

        /* NEW LAYOUT FLEX/GRID for Explanation + Params */
        .explanation-container {
            display: grid;
            grid-template-columns: 2fr 1fr; /* 2 parts explanation, 1 part params */
            gap: 1.5rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        @media (max-width: 900px) {
            .explanation-container {
                grid-template-columns: 1fr; /* Stack on smaller screens */
            }
        }
        
        /* Data Table Styling */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        
        .data-table th, .data-table td {
            padding: 0.8rem 1rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .data-table th {
            background: rgba(255, 255, 255, 0.05);
            color: #00f5ff;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .data-table tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        /* Colors for data indicators */
        .positive { color: #2ed573; }
        .negative { color: #ff4757; }
        .hold { color: #ffd32a; }
        
        /* Form & Input Styling (for parameters) */
        .param-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.5rem 0;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.05);
        }
        
        .param-group label {
            font-weight: 500;
            color: #aaa;
        }
        
        .param-group input[type="number"], .param-group span {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 0.5rem;
            border-radius: 5px;
            width: 80px;
            text-align: center;
        }
    </style>
</head>
<body>
    
    <div class="navbar">
        <a href="index.html" class="logo">AI Trading Pro</a>
        <ul class="nav-links">
            <li><a href="index.html">Dashboard</a></li> 
            <li><a href="portfolio.html">Portfolio</a></li>
            <li><a href="trading.html">Trading</a></li>
            <li><a href="analytics.html">Analytics</a></li>
            <li class="active"><a href="Q_learning.html" class="active">RL Analysis</a></li> 
            <li><a href="news.html">News</a></li>
            <li><a href="settings.html">Settings</a></li>
        </ul>
        <div class="user-info">
            <span class="user-avatar">AD</span>
        </div>
    </div>

    <div class="main-content">
        
        <div class="header">
            <h1>RL Analysis: Q-Learning</h1>
            <div id="market-status" class="market-status market-closed">Market Status</div>
        </div>
        
        <div class="dashboard-grid">

            <div class="card card-full">
                <h2>Reinforcement Learning (RL) Agent Configuration</h2>
                
                <div class="explanation-container">
                    <div>
                        <p>This page uses a **Q-Learning Agent** to analyze the stock market and recommend actions. The agent learns the optimal trading strategy through trial and error, aiming to maximize its cumulative reward (profit).</p>
                        <ul>
                            <li>**State:** Market conditions (price change, momentum, volatility).</li>
                            <li>**Action:** The decision taken: **BUY**, **HOLD**, or **SELL**.</li>
                            <li>**Reward:** The profit or loss incurred.</li>
                            <li>**Q-Table:** The internal map storing the "quality" (Q-value) of each state-action pair, guiding the agent's exploitation behavior.</li>
                        </ul>
                        <p style="margin-top: 1rem;">The agent starts with high **Exploration ($\epsilon$)** and gradually shifts to **Exploitation** as it gains confidence, leading to the live recommendations below.</p>
                    </div>

                    <div id="agent-params-section">
                        <h3>Agent Parameters & Performance</h3>
                        <div class="param-group">
                            <label for="learningRate">Learning Rate (α):</label>
                            <input type="number" id="learningRate" value="0.1" step="0.01">
                        </div>
                        <div class="param-group">
                            <label for="discountFactor">Discount (γ):</label>
                            <input type="number" id="discountFactor" value="0.95" step="0.01">
                        </div>
                        <div class="param-group">
                            <label>Exploration (ε):</label>
                            <span id="currentEpsilon">1.00</span> 
                        </div>
                        <div class="param-group">
                            <label>Total P&L:</label>
                            <span id="totalPnlDisplay" class="hold">$0.00</span>
                        </div>
                        <div class="param-group">
                            <label>Win Rate:</label>
                            <span id="winRateDisplay">0.00%</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="card card-full">
                <h2>Live Q-Learning Recommendations</h2>
                <p><strong>Overall Agent Action:</strong> <span id="overallAction" class="hold">HOLD</span></p>
                
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Price</th>
                            <th>Change %</th>
                            <th>Recommended Action</th>
                            <th>Confidence</th>
                        </tr>
                    </thead>
                    <tbody id="stock-recommendations">
                        <tr><td colspan="5" style="text-align:center; color:#888;">Fetching live data...</td></tr>
                    </tbody>
                </table>
            </div>

        </div>
    </div>

    <script>
        // --- 1. Q-Learning Agent Class ---
        class QLearningAgent {
            constructor(alpha, gamma, epsilon) {
                // Ensure elements exist before accessing
                const lrElement = document.getElementById('learningRate');
                const dfElement = document.getElementById('discountFactor');
                
                this.alpha = lrElement ? parseFloat(lrElement.value) : alpha; // Learning rate
                this.gamma = dfElement ? parseFloat(dfElement.value) : gamma; // Discount factor
                this.epsilon = epsilon; // Exploration rate (will decay)
                this.qTable = {}; // State-Action table
                this.actions = ['BUY', 'HOLD', 'SELL'];
                this.lastState = null;
                this.lastAction = null;
                this.totalTrades = 0;
                this.winningTrades = 0;
            }

            // Maps raw market data to a defined state string
            getState(priceChange, momentum, volatility) {
                const change = priceChange > 0.5 ? 'HIGH_POS' : priceChange < -0.5 ? 'HIGH_NEG' : priceChange > 0 ? 'LOW_POS' : priceChange < 0 ? 'LOW_NEG' : 'FLAT';
                const mom = momentum > 1 ? 'MOM_HIGH' : momentum < -1 ? 'MOM_LOW' : 'MOM_MID';
                const vol = volatility > 2 ? 'VOL_HIGH' : 'VOL_LOW';
                return `${change}_${mom}_${vol}`;
            }

            // Initializes Q-values for a new state
            initializeState(state) {
                if (!this.qTable[state]) {
                    this.qTable[state] = { 'BUY': 0, 'HOLD': 0, 'SELL': 0 };
                }
            }

            // Epsilon-greedy action selection
            chooseAction(state) {
                this.initializeState(state);

                // Decay epsilon over time for more exploitation
                const currentEpsilon = this.epsilon;
                const epsilonDisplay = document.getElementById('currentEpsilon');
                if (epsilonDisplay) epsilonDisplay.textContent = currentEpsilon.toFixed(2);

                if (Math.random() < currentEpsilon) {
                    // Exploration: Choose a random action
                    const action = this.actions[Math.floor(Math.random() * this.actions.length)];
                    return { action: action, confidence: (1 - currentEpsilon) };
                } else {
                    // Exploitation: Choose the best action from Q-table
                    const qValues = this.qTable[state];
                    let maxQ = -Infinity;
                    let bestAction = 'HOLD';
                    
                    for (const action in qValues) {
                        if (qValues[action] > maxQ) {
                            maxQ = qValues[action];
                            bestAction = action;
                        }
                    }
                    // Simple confidence based on how much better the best action is compared to the average
                    const avgQ = Object.values(qValues).reduce((a, b) => a + b, 0) / this.actions.length;
                    let confidence = Math.min(1, Math.max(0, (maxQ - avgQ) / 5 + 0.5)); // Scale and clamp
                    
                    return { action: bestAction, confidence: confidence };
                }
            }

            // The learning step: updates the Q-table based on the reward received
            update(oldState, action, reward, newState) {
                if (!oldState || !newState) return;
                
                // Update parameters from input fields live
                this.alpha = parseFloat(document.getElementById('learningRate').value);
                this.gamma = parseFloat(document.getElementById('discountFactor').value);


                this.initializeState(oldState);
                this.initializeState(newState);

                const oldQ = this.qTable[oldState][action];
                
                // Find the maximum Q-value for the new state (max a' Q(s', a'))
                const maxNewQ = Math.max(...Object.values(this.qTable[newState]));
                
                // Q-Learning Formula: Q(s, a) <- Q(s, a) + alpha * (Reward + gamma * max Q(s', a') - Q(s, a))
                const newQ = oldQ + this.alpha * (reward + this.gamma * maxNewQ - oldQ);
                this.qTable[oldState][action] = newQ;
            }
        }

        // --- 2. Simulation and Global Variables ---
        const symbols = ['AAPL', 'TSLA', 'GOOGL', 'MSFT', 'AMZN', 'NVDA'];
        let agent = null; // Initialize in DOMContentLoaded
        let totalPnl = 0;
        let lastPrices = {};
        let overallAction = 'HOLD';

        // --- 3. Helper Functions ---
        
        function updateMarketStatus() {
            const now = new Date();
            const currentHour = now.getHours();
            const currentDay = now.getDay();
            
            const isWeekday = currentDay >= 1 && currentDay <= 5;
            // Market hours (9:30 AM to 4:00 PM EST/EDT) - simplified check
            const isMarketHours = currentHour >= 9 && currentHour < 16; 
            const marketOpen = isWeekday && isMarketHours;
            
            const statusElement = document.getElementById('market-status');
            
            if (marketOpen) {
                statusElement.textContent = 'Market OPEN';
                statusElement.className = 'market-status market-open';
            } else {
                statusElement.textContent = 'Market CLOSED';
                statusElement.className = 'market-status market-closed';
            }
        }

        function calculateReward(lastPrice, currentPrice, action) {
            const priceDelta = currentPrice - lastPrice;
            let reward = 0;

            if (action === 'BUY') {
                reward = priceDelta;
            } else if (action === 'SELL') {
                reward = -priceDelta;
            } else { // HOLD
                // Small penalty for holding if there's significant movement
                reward = -Math.abs(priceDelta) * 0.1;
            }
            
            // Normalize the reward (e.g., scale by a fixed factor)
            return reward * 10;
        }

        // --- 4. Main Data Update Function ---
        async function updateStockData() {
            if (!agent) return; // Ensure agent is initialized
            
            console.log('Fetching live stock data...');

            const recommendationsBody = document.getElementById('stock-recommendations');
            recommendationsBody.innerHTML = '';
            
            let totalConfidence = 0;
            let buyCount = 0;
            let sellCount = 0;
            let holdCount = 0;

            for (const symbol of symbols) {
                // Simulate real-time stock data
                const basePrice = 150;
                // Add a random walk effect
                const currentPrice = basePrice + (Math.random() - 0.5) * 10 * (1 + Math.sin(Date.now() / 100000) * 0.5); 
                const priceChange = (currentPrice - basePrice) / basePrice * 100; // % change
                const momentum = (Math.random() - 0.5) * 4; // Simulated momentum
                const volatility = Math.random() * 5; // Simulated volatility

                const currentState = agent.getState(priceChange, momentum, volatility);
                const { action: recommendedAction, confidence } = agent.chooseAction(currentState);

                // Calculate reward and update Q-table based on *last* action (if any)
                if (lastPrices[symbol] && lastPrices[symbol].lastAction) {
                    const reward = calculateReward(lastPrices[symbol].price, currentPrice, lastPrices[symbol].lastAction);
                    const lastState = lastPrices[symbol].lastState;

                    agent.update(lastState, lastPrices[symbol].lastAction, reward, currentState);
                    
                    // Simple P&L update for simulation
                    if (lastPrices[symbol].lastAction === 'BUY') {
                        totalPnl += (currentPrice - lastPrices[symbol].price);
                        if (currentPrice > lastPrices[symbol].price) {
                             agent.winningTrades++;
                        }
                        agent.totalTrades++;
                    } else if (lastPrices[symbol].lastAction === 'SELL') {
                        totalPnl += (lastPrices[symbol].price - currentPrice);
                        if (lastPrices[symbol].price > currentPrice) {
                             agent.winningTrades++;
                        }
                        agent.totalTrades++;
                    }
                }
                
                // Store current data for next iteration's reward calculation
                lastPrices[symbol] = { 
                    price: currentPrice, 
                    lastState: currentState, 
                    lastAction: recommendedAction 
                };

                // Tally for overall action
                totalConfidence += confidence;
                if (recommendedAction === 'BUY') buyCount++;
                else if (recommendedAction === 'SELL') sellCount++;
                else holdCount++;

                // Determine class for styling
                const priceClass = priceChange > 0 ? 'positive' : priceChange < 0 ? 'negative' : 'hold';
                const actionClass = recommendedAction === 'BUY' ? 'positive' : recommendedAction === 'SELL' ? 'negative' : 'hold';

                // Add row to the table
                recommendationsBody.innerHTML += `
                    <tr>
                        <td>${symbol}</td>
                        <td>$${currentPrice.toFixed(2)}</td>
                        <td class="${priceClass}">${priceChange.toFixed(2)}%</td>
                        <td class="${actionClass}">${recommendedAction}</td>
                        <td>${(confidence * 100).toFixed(1)}%</td>
                    </tr>
                `;
            }
            
            // Update overall agent stats
            const pnlDisplay = document.getElementById('totalPnlDisplay');
            if(pnlDisplay){
                pnlDisplay.textContent = `$${totalPnl.toFixed(2)}`;
                const pnlClass = totalPnl > 0 ? 'positive' : totalPnl < 0 ? 'negative' : 'hold';
                pnlDisplay.className = pnlClass;
            }

            const winRateDisplay = document.getElementById('winRateDisplay');
            if(winRateDisplay){
                const winRate = agent.totalTrades > 0 ? (agent.winningTrades / agent.totalTrades) * 100 : 0;
                winRateDisplay.textContent = `${winRate.toFixed(2)}%`;
            }


            // Determine overall action based on majority and confidence
            const maxCount = Math.max(buyCount, sellCount, holdCount);
            if (maxCount === buyCount) overallAction = 'BUY';
            else if (maxCount === sellCount) overallAction = 'SELL';
            else overallAction = 'HOLD';

            const overallActionElement = document.getElementById('overallAction');
            if(overallActionElement){
                overallActionElement.textContent = overallAction;
                overallActionElement.className = overallAction === 'BUY' ? 'positive' : overallAction === 'SELL' ? 'negative' : 'hold';
            }
        }

        // --- 6. Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize agent after DOM is ready
            agent = new QLearningAgent(0.1, 0.95, 1.0); 
            
            updateMarketStatus();
            await updateStockData();
            
            // Set up recurring update every 30 seconds
            setInterval(async () => {
                updateMarketStatus();
                await updateStockData();
                // Epsilon decay for exploration
                agent.epsilon = Math.max(0.05, agent.epsilon * 0.995); 
            }, 30000);
        });

    </script>
</body>
</html>